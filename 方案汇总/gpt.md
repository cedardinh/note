Web3 高并发后端系统 Nonce 处理策略调研

Nonce 简介： 在以太坊等 EVM 链上，每个账户都有一个 nonce（交易计数器），用于保证交易顺序和防止重放攻击 ￼。每发出一笔交易，nonce 都会递增1，链上要求同一账户的交易按 nonce 顺序确认，不能跳号。如果同时并发发送多笔交易而未正确管理 nonce，就可能出现重复使用 nonce 导致“nonce has already been used”等错误 ￼ ￼。因此，在高并发场景下如何管理 nonce、避免冲突，是 Web3 后端架构必须解决的问题。

常见组件中的 Nonce 管理实现

在 Web3 行业实践中，不同类型的组件（如交易中继服务、智能合约钱包、交易节点服务等）各自实现了防止 nonce 冲突的机制：
	•	Biconomy Relayer： Biconomy 的中继引擎采用内部 nonce 追踪和多账户池来提高并发。它通过调用 eth_getTransactionCount(..., "pending") 获取包含未确认交易的最新 nonce，以允许单个账户并行发送多笔交易 ￼。同时，引擎维护内存缓存的 nonce，避免每次都请求节点，并将尽可能多的交易置于“pending”状态，只要不超过节点的交易池限制 ￼。为扩展吞吐，Biconomy 管理着上百个中继账户，跟踪每个账户的当前 nonce 和待确认交易数，并通过队列和调度将新交易分配给待处理交易最少的账户 ￼ ￼。这种架构避免单一账户成为瓶颈，同时确保每个账户的交易按序发送。
	•	Thirdweb Engine（后端钱包）： Thirdweb 团队在构建大规模链上写入服务时，实现了离链的全局 nonce 计数器。具体来说，他们使用一个原子性数据存储（如 Redis）集中跟踪每个发送钱包地址的 nonce ￼。并发发送交易时，服务会先从链上同步当前nonce值，然后在 Redis 中为每笔新交易分配自增的 nonce，确保不同事务拿到唯一的 nonce 后再签名发送 ￼。每当通过 RPC 提交交易成功后，才会递增保存的 nonce 计数 ￼。此外，Thirdweb 针对失败场景做了大量处理：例如预先模拟交易避免连Nonce递增但交易实际失败的情况，确保如果交易因执行出错或手续费不足等原因未真正发送，就不消耗nonce ￼；如果网络卡顿或交易池丢包导致交易过久未上链，也会超时取消以释放被占用的 nonce ￼。在可靠性保证之后，Thirdweb 还采用**工作队列(worker queue)**来控制高流量下的并发提交率：服务器将交易请求快速存入队列，再由后台工作线程异步取出处理（例如进行Gas预估和签名），从而削峰填谷，避免主线程因为5秒/笔的链上延迟而阻塞 ￼ ￼。总之，Thirdweb 的方案通过“离链 nonce 管理 + 失败恢复 + 队列限流”实现了在一个后台钱包上并发安全地发送多交易。
	•	Safe (Gnosis Safe) 智能钱包： 多签智能合约钱包 Safe 也有 nonce 概念，不过保存在合约状态中 (SafeTxNonce)。每执行一笔 Safe 交易，合约内 nonce 加1，新交易必须使用当前的 nonce 值。Safe 团队在前端提供交易队列界面：未执行的交易按照 nonce 排队等待 ￼。只有“等于上次执行交易的 nonce+1”的交易才能被执行，其它更高 nonce 的交易会暂存在队列中，直到前序交易执行完成 ￼。如果某笔交易卡住无法执行，用户可以选择提交一笔特殊的“取消交易”（通常是发送0 ETH到自身的空交易）来消耗当前nonce，使后续高nonce交易解锁执行。这种机制类似EOA账户的顺序要求，只是由合约维护顺序 ￼。因此 Safe 本身不支持真正的并发执行，只能通过队列+人工或自动取消来处理卡顿的顺序。
	•	Flashbots 交易服务节点： Flashbots 提供的 Protect RPC 和私有交易通道并未改变 Ethereum 本身的 nonce 规则，但在使用 Flashbots 时，pending nonce 的查询方式略有不同。因为通过 Flashbots 发送的交易不进入公共内存池，为了让用户仍能获取到包含私有交易在内的最新 nonce，需要对 eth_getTransactionCount("pending") 进行签名认证请求 ￼。Flashbots 要求调用方用钱包私钥签名查询请求，节点才会返回包括Flashbots私有交易在内的真实 pending nonce ￼。这一措施保证用户在用 Flashbots 发送并行交易时仍能正确跟踪 nonce（同时保证隐私，不向公开节点泄露未发布交易的信息）。总体而言，Flashbots 本身遵循以太坊nonce递增规则，用户需要像平常一样管理好每个账户的nonce，只是Flashbots提供了工具防止私有交易导致nonce查询不同步 ￼。
	•	Hyperledger FireFly: 面向企业的链上中间件 FireFly 内置了交易管理器（FFTM），其中包含Nonce 管理模块。FireFly 选择在“源头”就分配 nonce：在应用通过 FireFly 提交交易时，立即由 FireFly Connector 为该交易分配下一个nonce，且此操作有并发保护和持久化 ￼。具体来说，FireFly 在接受到并行的交易请求时，会确保对同一签名账户的请求串行分配nonce（例如使用内部锁或队列机制），不出现两个请求拿到相同的nonce ￼。分配的 nonce 会记录在 FireFly 的状态存储中，实现幂等：即使中间服务重启或崩溃，之前已分配的 nonce 不会丢失，不会重复使用 ￼。这种方案确保了应用层按严格顺序锁定交易次序，从源头杜绝了竞争条件。此外，FireFly 文档也提醒不要多处重复管理同一私钥的 nonce：如果某账户的交易有一部分不经过FireFly发送，可能导致链上nonce与FireFly内部状态不一致 ￼。如不得已出现多个系统并发使用同一私钥，FireFly 支持将 transactions.nonceStateTimeout 设置为极低值（如0或100毫秒），使其每次分配nonce前都查询链上最新pending nonce，以最大限度减少冲突窗口 ￼。总体来说，FireFly 的实现体现了企业系统偏好的集中式 nonce 分配服务：通过一个可靠的中间件组件，以事务方式管理nonce分配和交易提交。

以上示例涵盖了当前业界多种 nonce 管理方式，包括中继服务、智能钱包和企业桥接层。下面总结这些方案在高并发下避免 nonce 冲突所采用的策略。

高并发场景避免 Nonce 冲突的策略

面对多个实例/线程并发向同一链上账户发送交易，常见的避免 nonce 冲突的方法包括同步锁、乐观控制和基于队列的调度等：
	•	单实例串行化： 最简单的方法是强制对每个账户一次只处理一笔交易，即等待上一笔交易上链确认后再发送下一笔 ￼。这种方式本质上避免了一切并发，但吞吐量极低（每 ~12 秒仅1笔以太坊主网交易，Layer2上也要数秒一笔），无法满足实际需求 ￼。因此很少用于生产环境，但在系统遇到严重 nonce 冲突时，可能作为临时措施（例如某些钱包提供“Nonce 阻塞”提示用户等待）。
	•	全局锁/互斥: 即实现一个针对每个账户的分布式锁或临界区。当一个服务实例要发送交易时，先获取该账户的锁，查询当前链上nonce，同步或计算下一个nonce，发送交易后释放锁 ￼。这样保证同一时间只有一个实例对特定账户分配nonce，从而杜绝冲突。不过这种悲观锁方案在高并发下会引入阻塞等待，影响系统吞吐，需要确保锁机制高效且锁粒度足够细（通常以账户为粒度锁）。实际实现中，可以用 Redis 等实现分布式锁（如 SETNX）或者数据库的锁机制。Circle 的开发文档就建议“为每个钱包地址建立中心化的 nonce 追踪系统，可通过锁或队列来确保每个 nonce 只被分配一次” ￼。
	•	乐观并发控制: 另一种思路是不使用严格锁，而是利用原子操作防止冲突。例如，将每个账户的当前 nonce 保存在数据库或缓存中，多个并发请求直接尝试以“比较并交换（CAS）”方式更新这个 nonce 值：读取当前nonce，+1尝试写回，若发现有人抢先更新则重试。这类似乐观锁，通过版本号或条件更新保证每次只有一个成功者。Thirdweb 的离链nonce计数就是通过 Redis 原子递增来实现 ￼（Redis 的单线程操作天然原子）。相比全局锁，乐观法减少了锁等待时间，但需要处理写冲突重试。此外，乐观方案还要求对失败事务进行特别处理：如果某笔交易永远未上链（nonce “空洞”出现），系统需检测并回滚nonce（或重发交易） ￼。否则后续所有更高nonce的交易都会被区块链拒绝并卡住 ￼。因此，实现乐观并发时通常结合交易状态监控：监听交易是否打包上链，超时未确认则认为失败，释放或重置该 nonce，然后继续后续交易 ￼。这种方案复杂度较高，但在实际系统中被广泛采用，因为它不用严格锁住整个流程，只需保证nonce分配操作的原子性和失败补偿。
	•	队列与工作池: 很多高并发系统综合采用了队列调度机制，即将交易请求排入消息队列或任务列表，由有限的工作线程按序取出处理 ￼。比如Thirdweb和Openfort都建议使用Redis队列/RabbitMQ等，把快速到来的API请求存入队列，再由后台worker异步构建和提交交易 ￼ ￼。这样做有多重好处：(1)自然实现了对同一账户的顺序控制——可以按账户对任务分区，每个账户的交易由固定的worker串行执行，避免nonce竞争；(2)平滑高峰并减少资源占用——将链上慢操作与前端请求解耦，避免高并发直接打满节点或数据库连接 ￼。队列方案实际是一种软锁机制：通过调度策略避免同时两笔交易操作同一nonce。Biconomy 的架构中也有类似思想，他们维护了一个Relayer 队列和Pending计数管理，实时选择pending交易最少的账户执行下一笔交易 ￼。Hyperledger FireFly 内部实现则等价于一个每账户一个的FIFO队列，把并发API调用顺序化。总之，队列结合工作池是提高并发度又保证顺序的一种模式，被许多高吞吐交易系统采用 ￼。
	•	多账户并行: 虽非严格的“nonce管理”技术，但值得一提的是，有些场景下可以通过水平扩展账户来提高并发。因为不同地址各自有独立nonce，可以并行发送交易。比如，Biconomy在流量高峰时自动创建新中继账户并加入队列，以分摊负载 ￼ ￼。对于需要同时发送上千笔交易的应用，也有方案将批次交易分散由多个EOA地址发送，再在链上汇总效果（或由智能合约代为汇聚）。当然，多账户引入了资金分散和管理复杂度，往往需要Hierarchical Deterministic (HD) 钱包或托管服务支持，不是最理想方案 ￼。但在需要极限并发（如抢购、空投）且不要求交易严格按序的情况下，这是一种变通手段。

综上，高并发下避免 nonce 冲突通常依赖**“单账号串行、跨账号并行”的思路：对每个链上账户内部，通过锁、队列、原子操作等手段确保nonce不冲突；在系统整体上，通过多账户或者多worker并行来提高总吞吐。关键是在保证顺序性的同时，最大程度增加并行度，以及建立检测纠正机制处理nonce空洞等异常情况 ￼。例如，Circle 建议定期同步链上nonce状态，特别是在系统重启或出现交易失败后，及时健康检查**和对齐本地计数 ￼。

非以太坊链的 Nonce/交易顺序机制

不同区块链在交易顺序控制上有不同设计，有些并没有 Ethereum 式的 nonce 概念：
	•	Solana： Solana 并没有针对每个账户的递增 nonce 字段，而是通过交易签名+区块哈希来防重放和排序。每笔 Solana 交易需要包含一个**“recent blockhash”（最近区块哈希）作为新鲜度标识 ￼。交易ID本质上就是交易的签名，签名的输入包括交易内容和所选的 recent blockhash ￼。由于区块哈希不断变化，即使同一账户在同一区块发布两笔内容相同的交易，只要它们引用不同的blockhash，签名就完全不同，从而被视为两笔独立交易。这起到了类似nonce的作用：每笔交易都绑定一个只能使用一次的随机值（blockhash）。默认情况下，Solana节点会拒绝重复的签名**，并且如果交易引用的blockhash太旧（默认超过约150个slot，即~1-2分钟）则视为过期无效 ￼。因此，用户需要不断获取最新区块哈希来签署交易，以确保交易有效且不与自己近期交易ID冲突。并发方面，Solana 理论上允许同一账户同时发出多笔交易（不要求顺序nonce），但执行时仍需考虑状态冲突。Solana 的并行运行时会在执行前锁定交易涉及的账户状态：如果两笔并发交易试图同时写入同一账户（例如同一个钱包转账两次，会锁定该钱包的余额账户），后启动的交易必须等待前一笔释放锁才能执行。这意味着同一账户在一个 block 中连续的交易依然按某种顺序执行（由Leader调度），只是不会像以太坊那样因为nonce缺失而被直接丢弃，而是可能因为余额不足、状态已变化等原因导致失败或者成功。因此，Solana 没有传统意义上的“nonce冲突”问题，开发者更多关注的是确保使用最新blockhash以及处理可能的双重花费冲突。另外，Solana提供了**耐久性 Nonce（Durable Nonce）**的机制：通过创建一个特殊的Nonce账户储存一个稳定的哈希值，可用于长时间有效的离线交易签名场景 ￼。但这更多是为了离线交易容错，并非提升并发，而使用耐久 Nonce 时也需要在每次交易后手动“consume”旧 nonce 否则下一笔交易将与前一笔重复。
	•	Aptos (以及同源的 Diem/Sui 等)： Aptos 作为新一代并行链，虽然执行引擎支持并行处理，但在交易顺序上仍采用账户序列号（sequence number）机制，即每个账户每提交一笔交易序列号加1，类似以太坊nonce ￼。Aptos要求交易的 sequence number 必须严格等于链上当前值或比当前值更高才能被Mempool接收，但如果高于当前 +1，则中间存在缺失交易时不会进入共识 ￼。也就是说，如果账户当前序列号是5，你提交序号7，网络会等待序号6出现后才处理7 ￼。Aptos 允许一个账户并行存在多笔未确认交易，但有限制：官方文档指出每账户最多只能有100笔未决交易在网络中，否则超出的将被拒绝 ￼。并且如果通过不同节点提交超过100笔，可能有些节点会静默丢弃后面的交易 ￼。因此在Aptos上，并发发送需要注意分批和限流。Aptos文档也特别提醒，不要让多个系统独立分配同一账户的序列号，否则各自缓存状态不同会出现冲突；应让单一的交易管理器实例负责一个账户，以免“离线”状态导致sequence分配重复 ￼。总体而言，Aptos的nonce模型和以太坊类似，但结合其 Block-STM 并行执行引擎，实现了乐观并行：多个交易可以乱序进入区块执行，但最终仍以每账户sequence保证结果顺序一致。在并发管理上，Aptos鼓励使用类似以太坊的离链管理方案（如官方提供了Python的 Sequence Number Manager示例 ￼），同时利用链上每账户100笔的窗口，提高一定的并发度。
	•	Polygon zkEVM / 其他以太坊兼容链： 这些链遵循EVM规范，因此nonce机制与以太坊一致：每账户一个uint64计数 ￼。并发管理的挑战和解决方案与以太坊主网无异，比如Polygon zkEVM上如果一个账户并发提交多笔交易，同样需要防止nonce冲突，采用离链计数或pending查询等方法。同样，大多数以太坊 Layer2（Optimism、Arbitrum等）也保留了nonce顺序逻辑。因此，对这些链来说，本调研讨论的所有Nonce管理策略（锁、队列、AA等）同样适用。

(注：一些UTXO模型的链如比特币并无账户nonce概念，因为每笔交易通过引用未花费输出来保证唯一性；但这属于不同模型，本文聚焦账户模型的链。）

账户抽象 (ERC-4337) 中的并发与 Nonce 管理

以太坊的账户抽象（Account Abstraction，ERC-4337）引入了灵活的 nonce 机制，使智能账户可以支持多路并发交易流。传统EOA必须严格顺序nonce，而在ERC-4337中，每个 UserOperation 带有一个256位的nonce字段，账户合约可以自行定义nonce的结构和验证逻辑。其中一个常见设计是将nonce拆分为“两段”：高位作为Nonce Key（并行通道标识），低位作为Nonce Value（该通道内的序号) ￼。例如可以用64位作为 Key、192位作为计数，或者更极端一些方案用128/128拆分。这样，同一 Key 的操作需要顺序执行（Nonce Value 递增），但不同 Key 的操作可以并行而互不影响 ￼。账户合约会维护一个mapping(key => nonceValue)来跟踪每个通道的进度，在验证UserOp时允许多个通道各自独立的nonce。 ￼ ￼

一个具体示例是 Openfort 提出的“2D Nonce”方案：他们使用 nonce = nonceSequenceNumber[sender][key] | (key << 64) 形式组合出唯一的256位nonce，并在合约中按key存储和更新计数 ￼ ￼。通过这种方式，开发者可以人为划分交易组，例如将相关联的交易（需要按顺序的）使用相同的 key，不相关的交易使用不同 key，从而实现并发发送。 ￼举例来说，如果一个用户钱包需要同时执行三笔操作，其中两笔是连续的 swap 操作（相关联，必须按顺序），另一笔是购买NFT（独立于前两者），则可以为swap操作指定Key=1，为NFT操作指定Key=2。这样合约会认为Key=1的两笔要按序执行，而Key=2的可与它们并行执行 ￼。这极大缓解了顺序nonce的瓶颈，提高用户体验。

ERC-4337 规范本身对nonce结构并未强制，但在参考实现在文档中提到使用高位作为不同nonce空间的做法，以避免“invalid account nonce”错误并支持并行UserOp ￼。多数ERC-4337智能钱包（如StackUp、ZeroDev等实现）都支持这种多通道nonce。例如，有的实现允许钱包owner针对不同 dApp 模块使用不同的nonce key，从而同时进行多笔签名。 ￼此外，EntryPoint合约会确保同一账户+同一Nonce不能重复消费，类似地也能识别出nonce是否按每个key序列递增，避免并行操作破坏顺序。

需要注意，并行nonce并非毫无限制：如果用户不加管理地对同一 key并发发多笔交易，照样会因为nonce相同或乱序导致失败。因此在账户抽象模式下，钱包/客户端需要合理分配nonce key。例如一些钱包可能针对交易类型、目的合约等分类key，或者干脆每次签名都使用递增的新key以实现彻底并行（这种情况下需要某种bitmap记录key使用情况以防重复）。总的来说，账户抽象提供了协议层之外的软件层解决方案，允许愿意承担复杂度的智能账户摆脱固有的单线程nonce限制 ￼。这在抢跑交易、批量空投等场景非常有价值，可让单账户发挥类似多账户的并行能力。

研究性和创新方案

除了上述实用方案，社区和学术界也提出了一些创新性理念来改进 nonce 的并发处理：
	•	Nonce Bitmap（并行位图）提案： 这是2025年社区在以太坊研究论坛提出的一种新思路 ￼。其核心是利用目前nonce字段的未充分使用位来实现多并行nonce信道，且做到对现有钱包的向下兼容 ￼。具体而言，Nonce Bitmap 将一个账户nonce看作由多个bit位组成的位图，每一位代表一个“并行slot”。用户可以同时发起最多256笔并行交易，每笔交易对应位图中的一个bit位置 ￼。当某一位的nonce用过后标记为1，下次再用需要找一个未被占用的bit位。一旦一个bit位（slot）的交易被打包上链，该位释放可重复使用。链上需要为每个账户保存一个32字节（256位）的位图状态，记录哪些slot被占用 ￼。通过这种方式，用户能够无需改变私钥或创建多账户，就像拥有256条独立nonce序列一样并行发送交易。Nonce Bitmap 的优点在于：存储开销小（每账户32字节） ￼、对普通用户透明（如果只用第0号slot，相当于传统nonce顺序）、安全性不变（仍防重放） ￼。对于高频交易者（如套利机器人、做市商），Nonce Bitmap 能显著提升并发能力，减少因顺序等待错失良机的问题 ￼ ￼。值得一提的是，这一方案试图在协议层优化nonce机制，如果实施，将从根本上消除以太坊账户级的顺序瓶颈。当然，截至目前（2025年底）Nonce Bitmap 仍是研究提案，实际部署可能需要权衡兼容性和复杂度。
	•	多Nonce链和并行执行模型: 除了以太坊主网，也有项目探索从共识层改变交易顺序规则。例如一些并行链（如 Aptos、Sui）的设计初衷就是避免全局顺序等待，通过更先进的调度算法来并发执行交易。Sui 链采取“对象为中心”的并发模型：没有全局账户nonce，而是依赖对象版本号避免双重执行——只要两笔交易操作的是不同对象就可并行，即使来自同一账户也是如此。这种模型本质上把顺序控制的粒度缩小到资产/对象层面。不过，在Sui里如果同一钱包两笔交易消耗同一个Coin对象，那第二笔会因为引用的Coin已在第一笔中花费而失败，需要用户处理，无形中也要求顺序发送。因此纵观各种方案，不管是账户抽象的2D nonce、Nonce Bitmap，还是新链的对象并行，都是围绕缩小顺序依赖范围来提高并发。
	•	开源项目与论文: 在实践中，一些开源库和服务实现了上述理念。例如 OpenZeppelin Defender 的 Relay 服务内部就有Nonce管理器，自动处理pending nonce同步和冲突重试，开发者无需关心底层细节 ￼。又如 Alchemy、Infura 提供的交易API也声称会处理nonce问题。一些安全审计报告（如 Gas Station Network 的 audit）也讨论了 nonce 重放的风险和对策。论文方面，关于以太坊高吞吐的研究常提及nonce瓶颈以及 Layer2、AA 对它的改善。例如以太坊基金会研究员在 2020-2021 年间探讨过通过协议改进nonce的可能，但因需要兼容老账户，进展缓慢。近期的 ERC-4337 相关论文和报告则详细分析了多渠道nonce对于提升账户性能的作用 ￼。

综上，nonce 管理在 Web3 后端高并发处理中是一个横跨应用层和协议层的问题。目前业界多采用应用层方案（中继服务、队列、锁等）来缓解 nonce 顺序瓶颈，同时新标准（ERC-4337）和研究提案（Nonce Bitmap 等）正尝试从根本上提供并发能力。不同场景适用不同方案：例如交易量一般的DApp后台，用Redis锁+pending查询已足够；而高频交易机器人则可能需要考虑账户抽象或多账户并行；企业服务则倾向使用成熟组件（如FireFly）集中管理nonce。希望以上调研的诸多方案（每种方案说明及相关项目/链接已附上）能为您在设计高并发区块链系统时提供参考依据。

参考链接：
	1.	Openfort Blog – 2D Nonce: Transaction Parallelization ￼ ￼
	2.	Thirdweb Blog – Sending more than one transaction at a time… ￼ ￼
	3.	Ethereum Research Forum – Nonce Bitmap: Enabling Parallel Transaction… ￼ ￼
	4.	Biconomy Medium – Scaling Relayer Engine Infrastructure… ￼ ￼
	5.	Safe Help Center – Transaction Queue ￼
	6.	Flashbots Docs – Nonce Management (Flashbots Protect) ￼
	7.	Hyperledger FireFly Docs – Nonce management in transaction handler ￼ ￼
	8.	Circle Docs – Wallet Nonce Management ￼ ￼
	9.	Aptos Docs – Transaction Management (sequence numbers) ￼ ￼
	10.	Solana StackExchange – Transaction ID and blockhash uniqueness ￼
    
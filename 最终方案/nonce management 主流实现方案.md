# nonce management 主流实现方案

## 挖矿 Nonce

- **谁检查**：所有节点在验证区块时检查区块头哈希是否满足难度目标。
- **用于什么**：PoW 挖矿的可变字段，矿工不断改变它（及相关可变域）来反复计算哈希。
- **防什么攻击/达成什么**：通过“累计工作量成本”提高篡改历史/重组链成本，从而使 51% 类攻击变得昂贵。
- **解决的是**：给矿工提供足够大的搜索空间以找到满足难度的有效区块哈希。

## 交易 Nonce

- **谁检查**：它是链级共识的一部分，共识/执行层的所有节点都会检查（否则交易直接无效），用于确保交易顺序和防止重放攻击，用于账户交易计数器，确保交易唯一性（**tx nonce 防“交易层重放/排**）
- **防什么重放**：防的是同一个账户发的交易被重复执行、以及保证该账户交易严格按序（nonce 递增）
- **解决的是**：mempool 排序、替换交易（同 nonce 提 higher fee）、防止同账户并发乱序导致状态不一致

## 合约 Nonce

- **谁检查**：合约代码自己检查（EVM 执行时由所有节点执行同一段合约逻辑，因此结果仍然是“全网一致”）；不满足规则时合约 revert，交易可上链但该调用失败（状态回滚）。
- **用于什么**：作为“合约级计数器/一次性票据号”，绑定到某个合约内的某个主体（常见是 `user => nonce`，也可能是 `orderId => used`），确保某条合约指令/授权只被消费一次。
- **防什么重放**：防“指令层重放”——同一份链下签名授权、同一笔订单、同一条跨链消息，被打包进不同交易（甚至由不同提交者/relayer）重复执行。

# 不同链的 Nonce 实现方案

## 顺序账户 Nonce（以太坊式）

这是最常见的方案，以太坊及其兼容链（如Polygon、BSC）采用账户模型，每个账户维护一个 nonce 值，从 0 开始递增。每次交易必须使用当前 nonce+1 的值，节点会按顺序验证和执行。

- **优点**：实现简单，有效防止重放攻击和双花，确保交易严格有序。
- **缺点**：并发发送多笔交易时容易出现“nonce 太低”或交易卡住，需要手动管理或替换交易。
- **适用场景**：DeFi、智能合约交互等需要精确状态更新的应用，适合中低吞吐量但复杂逻辑的区块链。

## 持久 Nonce（Solana 式）

创建一个特殊的“nonce 账户”，里面存一个持久的“密码”（nonce 值）。交易从 Nonce 账户里领一个 nonce 值用于交易签名。无论过了多久（几小时甚至几天），只要这个 nonce 还没被使用，交易就一直有效。一旦交易成功上链，这 nonce 就作废，账户会自动生成一张新的 nonce 供下次使用。

- **优点**：交易不过期，支持长时间有效；适合异步处理。
- **缺点**：需额外创建和管理 nonce 账户，稍复杂。
- **适用场景**：高性能链、离线/冷钱包签名、多签协调、调度或跨链交易。

## UTXO 模型（比特币式，无传统 Nonce）

比特币不使用账户 nonce，而是通过未花费交易输出（UTXO）机制。交易消耗旧 UTXO 并创建新 ones，防止双花无需全局计数器。

- **优点**：天然并行处理，提升隐私（交易不易链接）；无需担心 nonce 冲突。
- **缺点**：不适合复杂状态管理，实现智能合约较难。
- **适用场景**：简单价值转移、隐私优先、高并行吞吐量的链，如 Bitcoin 或 Layer 2 扩展。

# 顺序账户 Nonce 管理

## 客户端处理（钱包 / dApp 前端）

### 1. 常用方案

- **链上实时查询策略**：每次发送交易都实时查询链上当前 **pending** nonce。
  - **优点**：是简单可靠，确保获取链上最新计数；
  - **缺点**：是在高并发时，多次同时查询可能返回相同值，导致 nonce 冲突，另外，某些节点对 pending 交易统计可能不及时，尤其是在未广播到公共内存池的交易情形下。
- **本地计数器策略**：本地维护一个 nonce 计数器，每发送一笔交易就对本地 nonce 加一，而不每次依赖链查询。
  - **优点**：是在并发场景下速度快、避免重复查询节点；并可批量签名多笔交易。当出现错误和冲突会立即查链上当前 `pending nonce`。
  - **缺点**：是在本地计数与链上状态不同步时可能产生错误：如有交易失败或被用户取消未实际发送，本地计数可能“跳号”；或者用户通过其他钱包发送交易导致链上 nonce 增加，而本地不知情。这都可能导致后续交易 nonce 过低或遗漏。
- **链上 + 本地组合策略**：很多钱包采用链上查询与本地跟踪相结合的方法，既确保不低于链上确认值，又包含本地未上链交易占用的 nonce。此策略需配合**锁机制**：在并发场景下，NonceTracker 会通过 `getNonceLock` 获取该地址的锁，算出 `nextNonce` 后占用该 nonce，直到交易签名并加入待发送队列才释放锁。
  - **MetaMask** 的 NonceTracker 会获取节点返回的下一个 nonce，同时查看钱包内部已提交但未确认的交易列表找出已使用的最高 nonce，然后取两者的最大值作为新的 nonce。
  - **MyCrypto** 等钱包也采用类似逻辑：每次需要 nonce 时，查询链上交易计数，并检查本地缓存的最近交易，用其中更大的 nonce 值+1。

### 2. 失败场景处理

如果签名失败或用户拒绝，需释放先前占用的 nonce 锁，并视情况决定是否重用该 nonce。一般而言，若交易从未广播，可以重用该 nonce；而一旦交易已签名广播，即便失败（例如链上执行失败/回滚），nonce 也会被消耗，不应重用。钱包通常提供“加速/取消”功能允许用户对挂起交易使用相同 nonce 发送一笔新交易（提高手续费或改为空交易）来替换掉原交易。如果出现本地记录与链上不一致（比如用户重置了钱包或更换设备），推荐做法是重新以链上状态为准（MetaMask 提供了重置账户 Nonce 的选项以清除本地记录，使后续 nonce 从链上获取）。

## 服务端层（Backend / Centralized）

### 常用方案

- **集中式数据库/锁**：设立一个全局的 nonce 记录存储。例如在数据库为每个地址保存当前可用 nonce，并利用事务或锁实现原子更新。当需要发送交易时，先**事务性地**读取并 +1 更新 nonce，然后取该值签名交易。保证任一时刻每个地址只有一个进程能成功获取并占用新的 nonce。
- **队列/单点服务**：将所有交易请求集中通过一个服务或队列按序处理。比如，所有需要链上发送的操作先放入消息队列，由单线程消费者逐个取出，顺序分配 nonce 并签名发送。这样天然避免并发冲突，但可能增加延迟。实际中，一些交易所系统可能采用“交易发送服务”集中负责与链交互，其内部串行化处理每个地址的交易。
- **多地址分片**：使用**多钱包地址**而非单一热钱包，可以极大提高并发度，不同用户或不同批次提现由不同地址发送，减少单地址上的顺序瓶颈。使用多个提现地址轮流发送可以提高吞吐并减轻单笔卡顿的影响。

### 失败场景处理

如果某笔交易长时间未上链（卡在内存池），会阻塞后续更高 nonce 交易的确认。因此监控 pending 交易并及时重推或替换非常重要。常见做法：如果检测到某地址有交易已 pending 很久未确认，可能由系统自动以更高手续费重发相同 nonce 交易或通知运维干预。绝不可跳过一个 nonce 直接发送后面的，否则后续交易会在节点 txpool 中排队直到前面 nonce 出现或被淘汰。此外，节点对每个地址能容纳的未确认交易数有上限（如 besu 每个 sender 默认是 200，mempool 中保留最大的交易数量默认 4096）。后端批量发送交易时需考虑这一限制，避免一下子推送过多交易导致超出池容量被拒。

大多数**交易所/托管服务应使用**中心化的 nonce 协调机制。首选方案是在数据库中维护每个地址的当前 nonce，并通过锁/事务保证并发安全。重启或异常情况下生成交易前先从链上获取最新确认 nonce 校准数据库，平时则信任数据库递增。另外结合**交易状态监控**。记录每个 nonce 交易的状态（未发送/已发送/已上链/失败），出现卡顿及时处理。

## 高频交易 / 套利 Bot 的 Nonce 管理

机器人（MEV 搜索者、套利交易程序等）追求极高的交易提交频率和成功率。它们能在极短时间内发送多笔交易。这个场景下会获取当前链上 nonce N，然后一次性签署多个交易，赋予 nonce N, N+1, N+2… 然后几乎同时发送，在区块链层面会让这些交易按照 nonce 顺序排队执行。如果卡住通常进行自动替换和重试。这一领域也催生了新的改进提案，例如**Nonce Bitmap** 等（将在下节提及），从协议层帮助高频用户突破单序列的限制。

## 大规模并发用户平台的 Nonce 管理

如果一个地址并发量极高，如果仍按严格顺序逐个发送，无法满足性能要求。那么基本思路类似交易所后台，使用多服务器实例处理，采用数据库集中分配或分布式锁确保多个应用服务器获取 nonce 时不冲突，另外系统可能将一个地址的交易请求分发到多个内部通道处理。

**Biconomy** 维护一组用于代付交易的签名账户（称为 relayers）。系统启动时，每个支持的链准备一批 relayer 地址放入队列。当有用户交易请求进来时，由**交易处理器**选择当前待命的 relayer 为其服务。选择依据是每个 relayer 当前 pending 交易数，优先选未决交易最少的，从而负载均衡未确认交易量。选定 relayer 后，通过内存缓存分配 nonce，并定期与链上同步以纠正偏差，因为纯粹依赖缓存可能出现不一致。当某 relayer 挂起交易过多或接近节点容量限制时，Biconomy 会启用下一个 relayer 地址接替（甚至动态创建新地址并加入队列）。这种架构使得平台可横向扩展到任意多实例和地址：如果一台服务器不够，可以部署多台，**每台管理自己的一组 relayer**，前面再用更高层的队列或负载均衡分发用户请求。